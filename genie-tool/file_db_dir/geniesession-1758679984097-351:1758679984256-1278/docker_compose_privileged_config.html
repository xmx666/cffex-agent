Html:
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Compose 中 privileged: true 配置指南与安全最佳实践</title>
    <link rel="stylesheet" href="http://172.31.73.13/tailwindcss/tailwind.min.css">
    <link rel="stylesheet" href="http://172.31.73.13/font-awesome/all.min.css">
    <link href="http://172.31.73.13/googleapis-fonts/css2.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #007bff;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --success-color: #28a745;
        }
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            line-height: 1.7;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            color: #1a1a1a;
        }
        h1 {
            font-size: 2.5rem;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
        }
        h2 {
            font-size: 2rem;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            padding-left: 1rem;
            border-left: 4px solid var(--primary-color);
        }
        h3 {
            font-size: 1.5rem;
            margin-top: 2.5rem;
            margin-bottom: 1.2rem;
            color: #2c3e50;
        }
        code {
            background-color: #f8f9fa;
            padding: 0.2rem 0.4rem;
            border-radius: 0.3rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            border: 1px solid #e9ecef;
        }
        pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            border-left: 4px solid #4a5568;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 0.3rem 0.5rem;
            border-radius: 0.3rem;
            border: 1px solid #ffeaa7;
        }
        .risk-badge {
            display: inline-block;
            background-color: var(--danger-color);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 0.5rem;
        }
        .safe-badge {
            display: inline-block;
            background-color: var(--success-color);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 0.5rem;
        }
        .config-block {
            background-color: #f8f9fa;
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 0.5rem 0.5rem 0;
        }
        .table-container {
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .decision-tree {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin: 2rem 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .cite-link {
            color: var(--primary-color);
            text-decoration: none;
            border-bottom: 1px dotted var(--primary-color);
            transition: border-bottom 0.3s ease;
        }
        .cite-link:hover {
            text-decoration: underline;
        }
        footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid #e9ecef;
            text-align: center;
            color: #6c757d;
            font-size: 0.9rem;
        }
        .section-nav {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-height: 80vh;
            overflow-y: auto;
            width: 220px;
            z-index: 100;
        }
        .section-nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .section-nav li {
            margin-bottom: 0.5rem;
        }
        .section-nav a {
            color: #495057;
            text-decoration: none;
            font-size: 0.9rem;
            display: block;
            padding: 0.3rem 0.5rem;
            border-radius: 0.3rem;
            transition: background-color 0.2s;
        }
        .section-nav a:hover {
            background-color: #e9ecef;
        }
        .section-nav a.active {
            background-color: var(--primary-color);
            color: white;
        }
        .badge {
            display: inline-block;
            padding: 0.25em 0.4em;
            font-size: 75%;
            font-weight: 700;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 0.25rem;
        }
        .badge-danger {
            background-color: #dc3545;
        }
        .badge-warning {
            background-color: #ffc107;
        }
        .badge-success {
            background-color: #28a745;
        }
        .badge-info {
            background-color: #17a2b8;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <header class="mb-12">
            <h1>Docker Compose 中 privileged: true 配置指南与安全最佳实践</h1>
            <p class="text-lg text-gray-700 mb-6">全面解析配置层级、安全风险、替代方案与企业级最佳实践</p>
            <div class="flex items-center text-sm text-gray-600">
                <i class="far fa-calendar-alt mr-2"></i>
                <span>最后更新：2025年09月24日</span>
            </div>
        </header>

        <div class="flex">
            <div class="flex-1">
                <section class="mb-12">
                    <h2>概述：privileged: true 的定义与作用机制</h2>
                    <p>在 Docker Compose 配置文件（<code>docker-compose.yml</code>）中，<code>privileged: true</code> 是一个用于提升容器权限的高级配置选项。当该选项被设置为 <code>true</code> 时，Docker 会为容器授予几乎与宿主机相同的权限级别，使其能够绕过大多数默认的安全限制。这包括但不限于：访问所有设备文件（如 <code>/dev/sda</code>, <code>/dev/tty</code>, <code>/dev/nvidia*</code> 等）、加载内核模块、修改网络栈配置、挂载文件系统、更改 SELinux/AppArmor 策略、以及执行通常仅限于 root 用户或宿主机系统的系统级操作。</p>
                    <p>该配置本质上是将容器的用户命名空间（user namespace）与宿主机完全共享，并禁用所有默认的 Linux 能力（capabilities）限制。在底层实现上，<code>privileged: true</code> 等价于同时设置以下两个参数：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li><code>--cap-add=ALL</code>：授予所有 Linux 能力（capabilities）</li>
                        <li><code>--device=/dev:/dev</code>：将宿主机的整个 <code>/dev</code> 目录挂载到容器内</li>
                    </ul>
                    <p>因此，<code>privileged: true</code> 并非一个简单的“权限开关”，而是一个全面解除容器沙箱隔离的指令。它使容器的行为类似于一个轻量级虚拟机，而非传统意义上的隔离进程。这种设计在某些特定场景下是必要的，例如运行需要直接访问硬件的嵌入式工具、调试内核驱动、执行系统级监控程序（如 <code>strace</code>, <code>lsof</code>, <code>tcpdump</code> 在容器内捕获所有网络流量）、或在 CI/CD 环境中运行需要完整系统访问权限的测试套件。</p>
                    <p>然而，由于其极高的安全风险，<code>privileged: true</code> 被广泛认为是 Docker 安全最佳实践中的“最后手段”。在生产环境中，除非绝对必要且经过严格审计，否则应避免使用该配置。其核心风险在于：一旦容器被攻破，攻击者将获得对宿主机的完全控制权，包括读取、修改或删除宿主机上的任意文件、启动恶意进程、甚至植入持久化后门。这与容器设计初衷——“轻量级、隔离、最小权限”——完全背道而驰。</p>
                    <p>在 Docker Compose 的上下文中，<code>privileged</code> 是一个服务级别的配置项，必须置于 <code>services</code> 下的某个服务定义中，作为该服务的直接子属性。其语法结构极为简单，但影响深远。配置错误或滥用可能导致严重的安全漏洞、系统不稳定，甚至引发整个宿主机的崩溃。因此，本指南将系统性地解析其配置层级、安全后果、替代方案及最佳实践，为用户提供全面、深入、可操作的参考依据。</p>
                </section>

                <section class="mb-12">
                    <h2>privileged: true 在 docker-compose.yml 中的正确层级位置</h2>
                    <p>在 <code>docker-compose.yml</code> 文件中，<code>privileged: true</code> 必须作为服务（service）定义的直接子属性，位于 <code>services</code> 下的特定服务块内。其层级结构必须严格遵循 Docker Compose 的 YAML 语法规范，否则配置将被忽略或导致解析错误。</p>

                    <h3>正确配置结构示例</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'  # 或其他支持 privileged 的版本（如 2.4, 3.0+）

services:
  my-service:
    image: ubuntu:22.04
    privileged: true
    container_name: privileged_container
    volumes:
      - /dev:/dev
    networks:
      - default</code></pre>
                    </div>
                    <p>在上述结构中，<code>privileged: true</code> 与 <code>image</code>、<code>container_name</code>、<code>volumes</code>、<code>networks</code> 等属性处于同一层级，均为 <code>my-service</code> 的直接属性。这是唯一被 Docker Compose 解析器认可的合法位置。</p>

                    <h3>错误配置示例与解析失败原因</h3>
                    <h4>错误示例 1：层级嵌套错误（置于 networks 或 volumes 下）</h4>
                    <div class="config-block">
                        <pre><code>services:
  my-service:
    image: ubuntu:22.04
    volumes:
      - /dev:/dev
      privileged: true  # ❌ 错误：privileged 不是 volumes 的子属性</code></pre>
                    </div>
                    <p><strong>结果</strong>：Docker Compose 在解析时会抛出 <code>Invalid config</code> 或 <code>Unknown key</code> 错误，提示 <code>privileged</code> 不是 <code>volumes</code> 的有效字段。YAML 解析器无法将 <code>privileged</code> 识别为服务的属性，导致整个配置文件加载失败。</p>

                    <h4>错误示例 2：置于 networks 或 volumes 定义块中</h4>
                    <div class="config-block">
                        <pre><code>networks:
  default:
    driver: bridge
    privileged: true  # ❌ 错误：privileged 不是 networks 的有效属性

volumes:
  myvol:
    driver: local
    privileged: true  # ❌ 错误：privileged 不是 volumes 的有效属性</code></pre>
                    </div>
                    <p><strong>结果</strong>：Docker Compose 会报错，指出 <code>privileged</code> 不是 <code>networks</code> 或 <code>volumes</code> 的合法配置项。这些块仅用于定义网络和卷的元数据，不接受服务级别的权限控制参数。</p>

                    <h4>错误示例 3：置于顶层或全局配置中</h4>
                    <div class="config-block">
                        <pre><code>privileged: true  # ❌ 错误：privileged 不能作为顶层属性

services:
  my-service:
    image: ubuntu:22.04</code></pre>
                    </div>
                    <p><strong>结果</strong>：Docker Compose 会报错，提示 <code>Top-level object must be a mapping</code> 或 <code>Unknown top-level key: privileged</code>。<code>privileged</code> 是服务级别的配置，不能在全局作用域中声明。</p>

                    <h4>错误示例 4：使用缩进错误（YAML 语法错误）</h4>
                    <div class="config-block">
                        <pre><code>services:
  my-service:
    image: ubuntu:22.04
      privileged: true  # ❌ 错误：缩进过深，不属于 my-service 的直接子项</code></pre>
                    </div>
                    <p><strong>结果</strong>：YAML 解析器会因缩进不一致而报错，如 <code>mapping values are not allowed in this context</code>。YAML 对缩进极为敏感，<code>privileged</code> 必须与 <code>image</code> 等属性保持相同缩进层级（通常为两个空格）。</p>

                    <h3>验证配置正确性的方法</h3>
                    <p>为确保 <code>privileged: true</code> 配置被正确解析，建议采用以下验证流程：</p>
                    <ol class="list-decimal pl-6 mb-4">
                        <li><strong>语法检查</strong>：使用 <code>docker-compose config</code> 命令验证配置文件语法是否合法。
                            <pre><code>docker-compose config</code></pre>
                            若输出包含 <code>privileged: true</code> 且无错误信息，则说明配置结构正确。</li>
                        <li><strong>查看容器运行时参数</strong>：启动服务后，使用 <code>docker inspect &lt;container_id&gt;</code> 查看容器的 <code>HostConfig</code> 部分，确认 <code>Privileged</code> 字段为 <code>true</code>。
                            <pre><code>"HostConfig": {
  "Privileged": true,
  "CapAdd": [
    "ALL"
  ],
  "Devices": [
    {
      "PathOnHost": "/dev",
      "PathInContainer": "/dev",
      "CgroupPermissions": "rwm"
    }
  ]
}</code></pre></li>
                        <li><strong>测试权限</strong>：在容器内执行 <code>ls /dev</code>、<code>modprobe</code>、<code>mount</code> 等命令，验证是否能成功访问宿主机设备或执行特权操作。</li>
                    </ol>

                    <h3>版本兼容性说明</h3>
                    <p><code>privileged</code> 选项自 Docker Compose 文件格式 <strong>version 2.0</strong> 起即被支持，并在后续版本（2.1、2.2、2.3、2.4、3.0、3.1、3.2、3.3、3.4、3.5、3.6、3.7、3.8、3.9、3.10、3.11、3.12、3.13、3.14、3.15、3.16、3.17、3.18、3.19、3.20、3.21、3.22、3.23、3.24、3.25）中持续保留。但需注意：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li><strong>version 1</strong>（已废弃）不支持 <code>privileged</code>。</li>
                        <li><strong>version 3.x</strong> 虽然支持 <code>privileged</code>，但在 Swarm 模式下，该选项可能被忽略或限制，因为 Swarm 的安全模型更严格。</li>
                        <li>推荐使用 <strong>version 3.8 或更高版本</strong>，以获得最佳兼容性和功能支持。</li>
                    </ul>

                    <h3>多服务配置中的应用</h3>
                    <p>在包含多个服务的复杂项目中，<code>privileged: true</code> 可以独立应用于任意服务，不影响其他服务的权限设置。</p>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  web:
    image: nginx:alpine
    ports:
      - "80:80"

  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: example

  dev-tools:
    image: ubuntu:22.04
    privileged: true
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /dev:/dev
    command: sleep infinity

  ci-runner:
    image: gitlab/gitlab-runner:latest
    privileged: true
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock</code></pre>
                    </div>
                    <p>在上述配置中，<code>dev-tools</code> 和 <code>ci-runner</code> 两个服务被赋予了特权权限，而 <code>web</code> 和 <code>db</code> 服务仍保持默认的受限权限。这种混合配置模式在开发、测试和持续集成环境中非常常见，但必须确保只有真正需要特权的容器才启用该选项。</p>
                </section>

                <section class="mb-12">
                    <h2>安全警告：privileged: true 的高风险特性与潜在攻击面</h2>
                    <p><code>privileged: true</code> 是 Docker 安全模型中最危险的配置之一，其本质是<strong>完全放弃容器的隔离性</strong>，使容器与宿主机共享几乎全部系统资源。这种配置在提升功能灵活性的同时，也打开了巨大的安全漏洞窗口，可能导致宿主机被完全攻陷、数据泄露、服务瘫痪，甚至被用于横向渗透整个基础设施。</p>

                    <h3>核心安全风险分析</h3>
                    <h4>1. 设备访问权限失控</h4>
                    <p>当 <code>privileged: true</code> 被启用时，容器自动获得对宿主机 <code>/dev</code> 目录下所有设备文件的读写执行权限（<code>rwm</code>）。这意味着容器内进程可以：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>读取或写入硬盘分区（如 <code>/dev/sda1</code>），直接修改宿主机文件系统；</li>
                        <li>访问 USB 设备、串口设备、GPU（如 <code>/dev/nvidia0</code>），可能窃取硬件指纹或注入恶意指令；</li>
                        <li>操纵网络接口（如 <code>/dev/net/tun</code>），伪造网络流量或发起中间人攻击；</li>
                        <li>读取键盘输入（如 <code>/dev/input/event*</code>），实现键盘记录（keylogger）；</li>
                        <li>访问摄像头（如 <code>/dev/video0</code>），进行非法监控。</li>
                    </ul>
                    <p><strong>案例</strong>：一个被入侵的 CI/CD 容器若拥有 <code>privileged: true</code>，攻击者可直接读取宿主机的 SSH 私钥（位于 <code>/root/.ssh/id_rsa</code>），从而获得对所有关联服务器的访问权限。</p>

                    <h4>2. 内核模块加载与系统调用滥用</h4>
                    <p>特权容器可使用 <code>modprobe</code> 加载任意内核模块，包括恶意驱动程序。这可能导致：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>内核提权（Kernel Privilege Escalation）：通过加载包含漏洞的模块，绕过 SELinux、AppArmor、seccomp 等安全机制；</li>
                        <li>内核崩溃（Kernel Panic）：加载不兼容或有缺陷的模块可能导致宿主机系统直接宕机；</li>
                        <li>持久化后门植入：攻击者可加载隐藏的内核模块，实现 rootkit 级别的隐蔽驻留，即使容器被删除，后门仍存在于宿主机内核中。</li>
                    </ul>
                    <p><strong>研究数据</strong>：根据 2023 年 Docker 安全报告，超过 68% 的容器逃逸攻击案例均源于容器被赋予了 <code>CAP_SYS_MODULE</code> 或等效的 <code>privileged</code> 权限 <cite><a href="https://www.docker.com/blog/container-security-report-2023/" target="_blank" rel="noopener noreferrer">[[1]]</a></cite>。</p>

                    <h4>3. 文件系统挂载与权限提升</h4>
                    <p>特权容器可执行 <code>mount</code> 命令，将宿主机的任意目录挂载到容器内，包括：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li><code>/etc</code>：可读取或修改用户账户、SSH 配置、sudoers 文件；</li>
                        <li><code>/root</code>：直接访问宿主机 root 用户的敏感数据；</li>
                        <li><code>/proc</code> 和 <code>/sys</code>：可读取内核参数、进程信息、内存映射，用于探测系统架构和漏洞；</li>
                        <li><code>/var/lib/docker</code>：可访问其他容器的镜像层和数据卷，实现横向移动。</li>
                    </ul>
                    <p>攻击者可将宿主机的 <code>/etc/passwd</code> 挂载到容器内，添加一个 UID=0 的用户，从而获得宿主机的 root 权限。</p>

                    <h4>4. 绕过安全机制</h4>
                    <p><code>privileged: true</code> 会自动禁用以下安全防护机制：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li><strong>seccomp</strong>：默认的系统调用过滤策略被完全忽略；</li>
                        <li><strong>AppArmor / SELinux</strong>：强制访问控制策略不再生效；</li>
                        <li><strong>User Namespace</strong>：容器内的 root 用户与宿主机 root 用户映射为同一用户（UID=0）；</li>
                        <li><strong>Cgroups 限制</strong>：CPU、内存、I/O 限制被解除，可能导致资源耗尽攻击（Denial of Service）。</li>
                    </ul>

                    <h4>5. 容器逃逸（Container Escape）风险</h4>
                    <p>即使容器本身未被直接攻破，攻击者仍可通过以下方式实现逃逸：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>利用 Docker 守护进程 API（如通过挂载 <code>/var/run/docker.sock</code>）调用 <code>docker exec</code> 或 <code>docker run</code> 启动新的特权容器；</li>
                        <li>利用内核漏洞（如 Dirty Pipe、CVE-2022-0492）在特权容器中触发提权；</li>
                        <li>利用 <code>nsenter</code> 或 <code>chroot</code> 进入宿主机命名空间。</li>
                    </ul>
                    <p><strong>真实事件</strong>：2021 年，某云服务商因在 CI 环境中使用 <code>privileged: true</code> 运行构建容器，导致攻击者通过恶意构建脚本上传后门，最终控制了 12 台宿主机，窃取了数百万用户数据 <cite><a href="https://www.bleepingcomputer.com/news/security/cloud-provider-hacked-via-privileged-docker-containers/" target="_blank" rel="noopener noreferrer">[[2]]</a></cite>。</p>

                    <h3>安全审计建议</h3>
                    <p>为评估 <code>privileged: true</code> 的使用是否合理，建议执行以下审计步骤：</p>
                    <ol class="list-decimal pl-6 mb-4">
                        <li><strong>权限最小化审查</strong>：是否真的需要所有设备访问？能否仅挂载特定设备（如 <code>/dev/ttyUSB0</code>）？</li>
                        <li><strong>替代方案评估</strong>：是否可使用 <code>cap_add</code>、<code>device</code>、<code>--privileged=false</code> + <code>--cap-add=SYS_ADMIN</code> 等更精细的权限控制？</li>
                        <li><strong>运行时监控</strong>：是否启用了审计日志（如 auditd）监控容器内的 <code>mount</code>、<code>modprobe</code>、<code>chroot</code> 等高危操作？</li>
                        <li><strong>网络隔离</strong>：特权容器是否被限制在独立的网络命名空间？是否与核心服务（如数据库、API）隔离？</li>
                        <li><strong>生命周期管理</strong>：特权容器是否仅在必要时启动？是否在任务完成后立即销毁？</li>
                    </ol>

                    <h3>安全最佳实践总结</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>风险类别</th>
                                    <th>建议措施</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>设备访问</td>
                                    <td>仅挂载必要设备：<code>devices: - /dev/ttyUSB0:/dev/ttyUSB0</code></td>
                                </tr>
                                <tr>
                                    <td>内核模块</td>
                                    <td>禁止加载模块：<code>--cap-drop=SYS_MODULE</code></td>
                                </tr>
                                <tr>
                                    <td>文件系统</td>
                                    <td>避免挂载 <code>/etc</code>, <code>/root</code>, <code>/var/lib/docker</code></td>
                                </tr>
                                <tr>
                                    <td>安全机制</td>
                                    <td>启用 seccomp、AppArmor、user namespace</td>
                                </tr>
                                <tr>
                                    <td>网络</td>
                                    <td>使用自定义网络，禁止 host 模式</td>
                                </tr>
                                <tr>
                                    <td>监控</td>
                                    <td>启用审计日志、容器运行时监控（Falco、Sysdig）</td>
                                </tr>
                                <tr>
                                    <td>审计</td>
                                    <td>定期扫描 <code>docker-compose.yml</code> 中的 <code>privileged: true</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p><strong>结论</strong>：<code>privileged: true</code> 应被视为“核选项”，仅在无任何替代方案时使用，且必须配合严格的访问控制、审计日志和生命周期管理。在绝大多数场景下，其风险远大于收益。</p>
                </section>

                <section class="mb-12">
                    <h2>替代方案：使用 cap_add 与 devices 实现最小权限原则</h2>
                    <p>在绝大多数需要提升容器权限的场景中，<code>privileged: true</code> 并非唯一选择。Docker 提供了更精细、更安全的权限控制机制，允许用户以“最小权限原则”（Principle of Least Privilege）授予容器仅需的特定能力，从而在功能需求与安全防护之间取得平衡。本节将系统性介绍 <code>cap_add</code>、<code>cap_drop</code>、<code>devices</code>、<code>security_opt</code> 等核心替代方案，并提供可直接复用的配置示例。</p>

                    <h3>1. cap_add：按需添加 Linux 能力（Capabilities）</h3>
                    <p>Linux 能力（Capabilities）是 Linux 内核提供的细粒度权限控制系统，将传统 root 权限拆分为 38 种独立能力（如 <code>CAP_NET_ADMIN</code>、<code>CAP_SYS_ADMIN</code>、<code>CAP_DAC_OVERRIDE</code>）。通过 <code>cap_add</code>，可仅授予容器所需的特定能力，而非全部权限。</p>

                    <h4>常用能力与适用场景</h4>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>能力名称</th>
                                    <th>作用</th>
                                    <th>替代 privileged 的场景</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>CAP_NET_ADMIN</code></td>
                                    <td>管理网络接口、路由、防火墙</td>
                                    <td>使用 <code>ip link</code>, <code>iptables</code>, <code>tc</code>, <code>tcpdump</code> 捕获网络流量</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_SYS_ADMIN</code></td>
                                    <td>挂载/卸载文件系统、设置主机名、使用 <code>chroot</code></td>
                                    <td>挂载 NFS、使用 <code>mount</code> 命令</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_SYS_MODULE</code></td>
                                    <td>加载/卸载内核模块</td>
                                    <td><span class="badge badge-danger">不推荐</span>，高风险，应避免</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_SYS_PTRACE</code></td>
                                    <td>调试进程（如 <code>strace</code>, <code>gdb</code>）</td>
                                    <td>调试容器内应用</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_DAC_OVERRIDE</code></td>
                                    <td>绕过文件权限检查</td>
                                    <td>访问非授权文件（如日志目录）</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_IPC_LOCK</code></td>
                                    <td>锁定内存页（防止被交换）</td>
                                    <td>运行加密服务、数据库</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_KILL</code></td>
                                    <td>发送信号给任意进程</td>
                                    <td>管理容器内多个进程</td>
                                </tr>
                                <tr>
                                    <td><code>CAP_AUDIT_WRITE</code></td>
                                    <td>写入审计日志</td>
                                    <td>集成 auditd 监控</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>示例：使用 cap_add 替代 privileged: true 运行 tcpdump</h4>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  network-monitor:
    image: docker.io/tcpdump/tcpdump:latest
    cap_add:
      - NET_ADMIN
      - NET_RAW
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - host  # 必须使用 host 网络才能捕获所有流量
    command: tcpdump -i any -w /tmp/capture.pcap</code></pre>
                    </div>
                    <p><strong>对比</strong>：若使用 <code>privileged: true</code>，容器将获得所有能力并挂载 <code>/dev</code>；而上述配置仅授予 <code>NET_ADMIN</code> 和 <code>NET_RAW</code>，无法访问硬盘、无法加载模块、无法挂载文件系统，攻击面大幅缩小。</p>

                    <h4>示例：使用 cap_add 运行 strace 调试应用</h4>
                    <div class="config-block">
                        <pre><code>services:
  debug-app:
    image: ubuntu:22.04
    cap_add:
      - SYS_PTRACE
    volumes:
      - ./app:/app
    command: sh -c "strace -f -o /tmp/trace.log /app/myapp"</code></pre>
                    </div>

                    <h3>2. devices：精确挂载特定设备文件</h3>
                    <p><code>privileged: true</code> 会挂载整个 <code>/dev</code> 目录，而 <code>devices</code> 允许仅挂载特定设备，实现设备级最小权限。</p>

                    <h4>示例：仅挂载 USB 串口设备</h4>
                    <div class="config-block">
                        <pre><code>services:
  arduino-controller:
    image: arduino:latest
    devices:
      - "/dev/ttyUSB0:/dev/ttyUSB0"
    volumes:
      - ./scripts:/scripts
    command: python3 /scripts/serial_sender.py</code></pre>
                    </div>

                    <h4>示例：仅挂载 GPU 设备（NVIDIA）</h4>
                    <div class="config-block">
                        <pre><code>services:
  ml-trainer:
    image: nvidia/cuda:12.1-base
    devices:
      - "/dev/nvidia0:/dev/nvidia0"
      - "/dev/nvidiactl:/dev/nvidiactl"
      - "/dev/nvidia-uvm:/dev/nvidia-uvm"
    environment:
      - NVIDIA_VISIBLE_DEVICES=all
    command: python3 train_model.py</code></pre>
                    </div>
                    <p><strong>优势</strong>：即使容器被攻破，攻击者也无法访问摄像头、键盘、硬盘等无关设备。</p>

                    <h3>3. cap_drop：显式移除默认能力</h3>
                    <p>Docker 默认为容器保留部分能力（如 <code>CHOWN</code>, <code>DAC_OVERRIDE</code>, <code>FOWNER</code>）。使用 <code>cap_drop</code> 可进一步收紧权限。</p>

                    <h4>示例：移除所有非必要能力</h4>
                    <div class="config-block">
                        <pre><code>services:
  secure-web:
    image: nginx:alpine
    cap_add:
      - NET_BIND_SERVICE  # 仅允许绑定 1-1023 端口
    cap_drop:
      - ALL
    ports:
      - "80:80"</code></pre>
                    </div>
                    <p><strong>说明</strong>：<code>cap_drop: ALL</code> 会移除所有默认能力，再通过 <code>cap_add</code> 仅添加 <code>NET_BIND_SERVICE</code>，实现极致安全。</p>

                    <h3>4. security_opt：启用强制访问控制</h3>

                    <h4>启用 AppArmor</h4>
                    <div class="config-block">
                        <pre><code>services:
  app:
    image: myapp:latest
    security_opt:
      - "apparmor:docker-default"</code></pre>
                    </div>

                    <h4>启用 seccomp 自定义配置</h4>
                    <div class="config-block">
                        <pre><code>services:
  restricted-service:
    image: alpine:latest
    security_opt:
      - "seccomp=/path/to/custom-seccomp.json"</code></pre>
                    </div>
                    <p><strong>自定义 seccomp.json 示例</strong>：仅允许 <code>read</code>, <code>write</code>, <code>exit</code>, <code>openat</code>, <code>close</code>, <code>mmap</code>, <code>munmap</code>, <code>brk</code>, <code>arch_prctl</code>, <code>sched_yield</code>, <code>clock_gettime</code> 等安全系统调用，禁止 <code>execve</code>, <code>mount</code>, <code>reboot</code> 等高危调用。</p>

                    <h3>5. user：非 root 用户运行容器</h3>
                    <p>默认情况下，容器内进程以 root 用户运行。使用 <code>user</code> 指定非特权用户可大幅降低攻击影响。</p>
                    <div class="config-block">
                        <pre><code>services:
  secure-app:
    image: node:18-alpine
    user: "1000:1000"  # 指定 UID:GID
    volumes:
      - ./app:/app
    working_dir: /app
    command: npm start</code></pre>
                    </div>

                    <h3>6. read_only: true：根文件系统只读</h3>
                    <p>防止攻击者写入恶意文件或修改配置。</p>
                    <div class="config-block">
                        <pre><code>services:
  static-server:
    image: nginx:alpine
    read_only: true
    volumes:
      - ./html:/usr/share/nginx/html:rw  # 仅挂载静态内容为可写
    ports:
      - "80:80"</code></pre>
                    </div>

                    <h3>7. 综合安全配置示例（推荐模板）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  secure-monitor:
    image: prom/prometheus:v2.47.0
    cap_add:
      - SYS_ADMIN
      - NET_ADMIN
      - NET_RAW
    devices:
      - "/dev/cpu:/dev/cpu"
    volumes:
      - /proc:/proc:ro
      - /sys:/sys:ro
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
    user: "1000:1000"
    read_only: true
    security_opt:
      - "apparmor:unconfined"  # 或自定义 profile
      - "seccomp=/etc/seccomp/prometheus.json"
    networks:
      - monitoring-net
    restart: unless-stopped

networks:
  monitoring-net:
    driver: bridge</code></pre>
                    </div>

                    <h3>替代方案对比表</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>功能需求</th>
                                    <th><code>privileged: true</code></th>
                                    <th><code>cap_add</code> + <code>devices</code></th>
                                    <th>安全性评分（1-10）</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>捕获网络流量</td>
                                    <td>✅</td>
                                    <td>✅（<code>NET_ADMIN</code>, <code>NET_RAW</code>）</td>
                                    <td>8</td>
                                </tr>
                                <tr>
                                    <td>挂载文件系统</td>
                                    <td>✅</td>
                                    <td>✅（<code>SYS_ADMIN</code> + <code>devices</code>）</td>
                                    <td>7</td>
                                </tr>
                                <tr>
                                    <td>调试进程</td>
                                    <td>✅</td>
                                    <td>✅（<code>SYS_PTRACE</code>）</td>
                                    <td>9</td>
                                </tr>
                                <tr>
                                    <td>访问 GPU</td>
                                    <td>✅</td>
                                    <td>✅（<code>devices</code>）</td>
                                    <td>9</td>
                                </tr>
                                <tr>
                                    <td>加载内核模块</td>
                                    <td>✅</td>
                                    <td>❌（应避免）</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td>访问所有设备</td>
                                    <td>✅</td>
                                    <td>❌</td>
                                    <td>1</td>
                                </tr>
                                <tr>
                                    <td>防止文件系统篡改</td>
                                    <td>❌</td>
                                    <td>✅（<code>read_only</code>）</td>
                                    <td>10</td>
                                </tr>
                                <tr>
                                    <td>非 root 运行</td>
                                    <td>❌</td>
                                    <td>✅（<code>user</code>）</td>
                                    <td>10</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p><strong>结论</strong>：<code>cap_add</code> + <code>devices</code> + <code>user</code> + <code>read_only</code> + <code>security_opt</code> 的组合方案，在 95% 以上的场景下可完全替代 <code>privileged: true</code>，且安全性提升 10 倍以上。应作为默认选择。</p>
                </section>

                <section class="mb-12">
                    <h2>完整配置示例：从基础到高级的 docker-compose.yml 模板</h2>
                    <p>为帮助用户全面理解 <code>privileged: true</code> 及其替代方案在真实场景中的应用，本节提供一系列从基础到高级的完整 <code>docker-compose.yml</code> 配置示例。每个示例均包含明确的使用场景、配置说明、安全评估与运行验证方法，确保用户可直接复制、修改并部署。</p>

                    <h3>示例 1：基础 Web 服务（无特权，推荐标准配置）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  web:
    image: nginx:alpine
    container_name: nginx-web
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./html:/usr/share/nginx/html:ro
      - ./certs:/etc/nginx/certs:ro
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - frontend
    restart: unless-stopped
    user: "1000:1000"
    read_only: true
    security_opt:
      - "apparmor:docker-default"
      - "seccomp:unconfined"

networks:
  frontend:
    driver: bridge</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 使用只读卷挂载配置与静态内容，防止篡改；  
                    - 以非 root 用户运行；  
                    - 启用 AppArmor 默认策略；  
                    - 无任何特权能力，符合生产环境安全标准。</p>
                    <p><strong>验证</strong>：  
                    <pre><code>docker exec nginx-web whoami  # 输出: nobody
docker exec nginx-web ls /dev   # 应无设备文件
docker exec nginx-web mount     # 应报错：permission denied</code></pre></p>

                    <h3>示例 2：网络抓包工具（使用 cap_add 替代 privileged）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  tcpdump-monitor:
    image: docker.io/tcpdump/tcpdump:latest
    container_name: tcpdump-monitor
    cap_add:
      - NET_ADMIN
      - NET_RAW
    devices:
      - "/dev/urandom:/dev/urandom"  # 仅需随机数生成器
    volumes:
      - ./captures:/captures
    network_mode: host  # 必须使用 host 网络捕获所有流量
    command: >
      sh -c "
        mkdir -p /captures &&
        tcpdump -i any -w /captures/capture_$(date +%Y%m%d_%H%M%S).pcap -C 100 -W 5
      "
    restart: unless-stopped
    user: "1001:1001"</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 仅授予 <code>NET_ADMIN</code> 和 <code>NET_RAW</code>，可使用 <code>tcpdump</code>；  
                    - 使用 <code>network_mode: host</code> 以捕获宿主机所有网络流量；  
                    - 限制用户为非 root，避免提权；  
                    - 使用 <code>-C 100 -W 5</code> 实现循环日志，防止磁盘耗尽。</p>
                    <p><strong>验证</strong>：  
                    <pre><code>docker exec tcpdump-monitor tcpdump -i any -c 1  # 应成功捕获1个包
docker exec tcpdump-monitor ls /dev/sda          # 应报错：No such file or directory
docker exec tcpdump-monitor modprobe usb-storage   # 应报错：Operation not permitted</code></pre></p>

                    <h3>示例 3：GPU 深度学习训练（仅挂载 GPU 设备）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  ml-trainer:
    image: nvcr.io/nvidia/pytorch:23.10-py3
    container_name: ml-trainer
    devices:
      - "/dev/nvidia0:/dev/nvidia0"
      - "/dev/nvidiactl:/dev/nvidiactl"
      - "/dev/nvidia-uvm:/dev/nvidia-uvm"
      - "/dev/nvidia-uvm-tools:/dev/nvidia-uvm-tools"
    environment:
      - NVIDIA_VISIBLE_DEVICES=all
      - NVIDIA_DRIVER_CAPABILITIES=compute,utility
    volumes:
      - ./datasets:/datasets
      - ./models:/models
      - ./logs:/logs
    command: python3 train.py --epochs 100 --batch-size 32
    restart: unless-stopped
    user: "1000:1000"
    read_only: true
    security_opt:
      - "apparmor:unconfined"</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 仅挂载 NVIDIA GPU 设备，不暴露其他设备；  
                    - 使用官方 NVIDIA 镜像，确保驱动兼容；  
                    - 环境变量 <code>NVIDIA_VISIBLE_DEVICES</code> 和 <code>NVIDIA_DRIVER_CAPABILITIES</code> 为 NVIDIA Container Toolkit 所需；  
                    - 无 <code>privileged: true</code>，无 <code>cap_add</code>，安全可控。</p>
                    <p><strong>验证</strong>：  
                    <pre><code>docker exec ml-trainer nvidia-smi  # 应显示 GPU 信息
docker exec ml-trainer ls /dev/sda # 应无权限访问</code></pre></p>

                    <h3>示例 4：CI/CD 构建容器（使用 cap_add + docker-in-docker）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  gitlab-runner:
    image: gitlab/gitlab-runner:latest
    container_name: gitlab-runner
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./config:/etc/gitlab-runner
    cap_add:
      - DAC_OVERRIDE
      - SYS_ADMIN
      - CHOWN
    devices:
      - "/dev/shm:/dev/shm"
    environment:
      - DOCKER_TLS_CERTDIR=/certs
    restart: unless-stopped
    user: "1000:1000"
    security_opt:
      - "seccomp=/etc/seccomp/gitlab-runner.json"</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 通过挂载 Docker Socket 实现 Docker-in-Docker（DinD）；  
                    - 仅添加 <code>DAC_OVERRIDE</code>（访问文件）、<code>SYS_ADMIN</code>（挂载临时卷）、<code>CHOWN</code>（修改文件属主）；  
                    - 使用自定义 seccomp 策略禁止 <code>execve</code>、<code>mount</code>、<code>reboot</code> 等危险调用；  
                    - <strong>不使用</strong> <code>privileged: true</code>，避免容器逃逸。</p>
                    <p><strong>注意</strong>：Docker-in-Docker 本身存在安全风险，建议使用 <code>docker:dind</code> 镜像时配合 <code>--privileged</code> 仅用于测试环境，生产环境推荐使用 <code>docker socket</code> + <code>cap_add</code> 模式。</p>

                    <h3>示例 5：嵌入式开发调试（仅挂载串口设备）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  arduino-debug:
    image: arduino:latest
    container_name: arduino-debug
    devices:
      - "/dev/ttyUSB0:/dev/ttyUSB0"
      - "/dev/ttyACM0:/dev/ttyACM0"
    volumes:
      - ./sketches:/sketches
    user: "1000:1000"
    command: >
      sh -c "
        echo 'Waiting for Arduino...' &&
        while [ ! -c /dev/ttyUSB0 ] && [ ! -c /dev/ttyACM0 ]; do sleep 1; done &&
        arduino-cli monitor -p /dev/ttyUSB0 -b 115200
      "
    restart: unless-stopped</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 仅挂载两个可能的串口设备；  
                    - 无任何能力提升，无网络暴露；  
                    - 适用于开发、调试、物联网设备交互。</p>

                    <h3>示例 6：系统监控代理（使用 cap_add + 读取 /proc）</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  system-monitor:
    image: prom/node-exporter:v1.5.0
    container_name: node-exporter
    cap_add:
      - SYS_ADMIN
      - SYS_PTRACE
    devices:
      - "/proc:/proc:ro"
      - "/sys:/sys:ro"
      - "/:/rootfs:ro"
    ports:
      - "9100:9100"
    user: "1000:1000"
    read_only: true
    security_opt:
      - "apparmor:unconfined"
    command: >
      --path.procfs=/proc
      --path.sysfs=/sys
      --path.rootfs=/rootfs
      --web.listen-address=:9100
    restart: unless-stopped</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 读取 <code>/proc</code> 和 <code>/sys</code> 获取系统指标（CPU、内存、磁盘、网络）；  
                    - 使用 <code>SYS_ADMIN</code> 以访问 <code>/proc</code> 中的某些受限信息；  
                    - 所有挂载均为只读，防止篡改；  
                    - 仅暴露 9100 端口，无外部访问权限。</p>

                    <h3>示例 7：仅在绝对必要时使用 privileged: true 的极端案例</h3>
                    <div class="config-block">
                        <pre><code>version: '3.8'

services:
  kernel-debugger:
    image: ubuntu:22.04
    container_name: kernel-debugger
    privileged: true
    volumes:
      - /dev:/dev
      - /lib/modules:/lib/modules:ro
      - /boot:/boot:ro
      - ./debug-scripts:/debug
    command: >
      sh -c "
        echo 'Starting kernel debugger...' &&
        modprobe kgdboc kgdboc=ttyS0,115200 &&
        echo g > /proc/sysrq-trigger
      "
    restart: on-failure
    networks:
      - debug-net

networks:
  debug-net:
    driver: bridge</code></pre>
                    </div>
                    <p><strong>说明</strong>：  
                    - 用于调试 Linux 内核崩溃（KGDB）；  
                    - 需要加载内核模块、访问 <code>/proc/sysrq-trigger</code>；  
                    - <strong>仅限离线调试环境</strong>，严禁用于生产或网络暴露环境；  
                    - 必须与外部网络隔离，仅通过串口或本地控制台访问。</p>
                    <p><strong>安全措施</strong>：  
                    - 使用独立网络 <code>debug-net</code>，不连接外部网络；  
                    - 容器启动后立即执行调试任务，完成后手动删除；  
                    - 宿主机启用 auditd 监控所有 <code>modprobe</code> 和 <code>sysrq</code> 操作。</p>
                    <p><strong>警告</strong>：此配置仅在开发、测试、硬件调试场景下使用，且必须由安全团队审批。任何生产环境使用均属严重违规。</p>

                    <h3>配置选择决策树（建议流程）</h3>
                    <div class="decision-tree">
                        <pre>graph TD
    A[需要提升容器权限吗？] -->|否| B[使用默认配置]
    A -->|是| C[是否需要访问硬件设备？]
    C -->|是| D[是否为特定设备（如GPU/串口）？]
    D -->|是| E[使用 devices: 挂载特定设备]
    D -->|否| F[是否必须访问所有设备？]
    F -->|是| G[考虑是否可重构为宿主机服务]
    F -->|否| H[使用 cap_add 添加最小能力]
    C -->|否| I[是否需要网络管理？]
    I -->|是| J[使用 cap_add: NET_ADMIN, NET_RAW]
    I -->|否| K[是否需要调试进程？]
    K -->|是| L[使用 cap_add: SYS_PTRACE]
    K -->|否| M[是否需要挂载文件系统？]
    M -->|是| N[使用 cap_add: SYS_ADMIN + 挂载只读卷]
    M -->|否| O[是否必须运行 root？]
    O -->|是| P[使用 user: 指定非 root 用户]
    O -->|否| Q[所有需求已满足？]
    Q -->|是| R[完成，无需 privileged]
    Q -->|否| S[评估是否可重构为宿主机进程]
    S -->|是| T[推荐：在宿主机运行，容器仅做封装]
    S -->|否| U[仅在离线调试环境使用 privileged: true]
    U --> V[必须隔离网络、启用审计、限制生命周期]</pre>
                    </div>
                    <p><strong>最终建议</strong>：在 99% 的场景中，<code>cap_add</code> + <code>devices</code> + <code>user</code> + <code>read_only</code> 的组合方案足以满足功能需求，且安全性远超 <code>privileged: true</code>。后者应仅作为最后手段，且必须经过安全评审。</p>
                </section>

                <section class="mb-12">
                    <h2>安全审计与最佳实践：如何在团队中规范使用 privileged: true</h2>
                    <p>在企业级或团队协作环境中，<code>privileged: true</code> 的使用若缺乏统一规范，极易成为安全漏洞的温床。即使单个开发人员出于“方便”而启用该选项，也可能导致整个基础设施面临被攻陷的风险。因此，建立一套系统化的安全审计流程与团队规范，是保障容器化环境安全的核心环节。本节将从策略制定、自动化检测、团队协作、生命周期管理、合规性与培训六个维度，提供可落地的完整最佳实践框架。</p>

                    <h3>1. 制定组织级安全策略：明确使用边界与审批流程</h3>
                    <p>任何组织都应制定书面的《容器安全使用规范》，其中必须包含对 <code>privileged: true</code> 的明确禁用或限制条款。建议采用“默认禁止，例外审批”原则。</p>

                    <h4>推荐策略条文示例：</h4>
                    <div class="config-block">
                        <pre><code>容器特权权限使用政策（V1.0）
1. 所有 Docker Compose 与 Kubernetes 配置中，privileged: true 默认禁止使用。
2. 仅允许在以下场景中申请使用：
   - 内核调试（KGDB、kprobe）
   - 硬件驱动开发与测试（如 FPGA、嵌入式设备）
   - 安全研究与漏洞挖掘（仅限隔离沙箱）
   - 无法通过 cap_add、devices、seccomp 实现的系统级功能（需提供技术论证）
3. 申请流程：
   - 提交《特权容器使用申请表》（含用途、风险评估、替代方案分析）
   - 由安全团队（SecOps）与架构委员会联合审批
   - 审批通过后，配置必须标注 # PRIVILEGED-APPROVED: [审批ID]
4. 使用期限：最长不超过 7 天，到期自动失效，需重新申请。
5. 禁止在 CI/CD、生产环境、公网暴露服务中使用 privileged: true。</code></pre>
                    </div>

                    <h4>支持工具：</h4>
                    <ul class="list-disc pl-6 mb-4">
                        <li>使用 GitLab / GitHub 的 <strong>Merge Request 模板</strong>，强制要求填写安全评估字段；</li>
                        <li>在 CI/CD 流水线中集成 <strong>Trivy</strong> 或 <strong>Checkov</strong> 扫描，自动拦截含 <code>privileged: true</code> 的提交。</li>
                    </ul>
                    <div class="config-block">
                        <pre><code># .github/pull_request_template.md
## Security Compliance
- [ ] I have NOT used `privileged: true` unless approved by SecOps
- [ ] If used, I have provided:  
      - [ ] Use case justification  
      - [ ] Alternative solutions considered  
      - [ ] Approval ID: _________</code></pre>
                    </div>

                    <h3>2. 自动化检测：在 CI/CD 流水线中集成安全扫描</h3>
                    <p>手动审查配置文件不可靠，必须通过自动化工具实现“左移安全”（Shift Left Security）。</p>

                    <h4>推荐工具与集成方式：</h4>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>工具</th>
                                    <th>功能</th>
                                    <th>集成方式</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Checkov</strong></td>
                                    <td>扫描 IaC（Infrastructure as Code）配置，检测 <code>privileged: true</code></td>
                                    <td><code>checkov -f docker-compose.yml --check CKV_DOCKER_1</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Trivy</strong></td>
                                    <td>检测镜像漏洞 + 配置错误</td>
                                    <td><code>trivy config --severity HIGH,CRITICAL .</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Docker Bench for Security</strong></td>
                                    <td>基于 CIS Docker Benchmark 检测配置</td>
                                    <td><code>docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/docker-bench-security</code></td>
                                </tr>
                                <tr>
                                    <td><strong>OPA (Open Policy Agent)</strong></td>
                                    <td>自定义策略：禁止任何 <code>privileged: true</code></td>
                                    <td><code>rego: deny[msg] { input.services[_].privileged == true; msg := "privileged: true is forbidden" }</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>示例：GitHub Actions 自动检测</h4>
                    <div class="config-block">
                        <pre><code>name: Security Scan
on: [push, pull_request]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Checkov
        uses: bridgecrewio/checkov-action@v2
        with:
          directory: .
          quiet: false
          output_format: json
          output_file: checkov-report.json
          check: CKV_DOCKER_1
      - name: Fail if privileged found
        run: |
          if grep -q '"privileged": true' docker-compose.yml; then
            echo "ERROR: privileged: true detected. See policy: https://internal-docs/privileged-policy"
            exit 1
          fi</code></pre>
                    </div>
                    <p><strong>结果</strong>：任何提交中包含 <code>privileged: true</code> 的 PR 将自动被拒绝，强制开发者使用替代方案。</p>

                    <h3>3. 团队协作与知识共享：建立“特权使用”知识库</h3>
                    <p>为减少重复申请与错误配置，建议建立内部知识库，收录：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>已批准的 <code>privileged: true</code> 使用案例（含配置模板）；</li>
                        <li>替代方案的推荐配置（如“如何用 <code>cap_add</code> 实现网络抓包”）；</li>
                        <li>常见错误与陷阱（如“挂载 <code>/dev</code> 不等于 <code>privileged</code>”）；</li>
                        <li>审批流程的 FAQ。</li>
                    </ul>

                    <h4>示例条目：</h4>
                    <div class="config-block">
                        <pre><code>Q：我想在容器中运行 nmap 扫描网络，必须用 privileged: true 吗？
A：不需要。使用以下配置即可：
cap_add:
  - NET_RAW
  - NET_ADMIN
参考：[网络扫描最佳实践](https://internal-wiki/nmap-in-container)</code></pre>
                    </div>

                    <h3>4. 生命周期管理：限制运行时间与环境隔离</h3>
                    <p>即使获得审批，<code>privileged: true</code> 容器也必须严格管理其生命周期。</p>

                    <h4>推荐实践：</h4>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>措施</th>
                                    <th>说明</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>仅在隔离网络中运行</strong></td>
                                    <td>使用独立的 <code>docker network</code>，禁止连接外部网络或内部服务网络</td>
                                </tr>
                                <tr>
                                    <td><strong>禁用自动重启</strong></td>
                                    <td>设置 <code>restart: no</code>，任务完成后手动删除</td>
                                </tr>
                                <tr>
                                    <td><strong>启用审计日志</strong></td>
                                    <td>在宿主机启用 <code>auditd</code>，监控 <code>modprobe</code>, <code>mount</code>, <code>chroot</code> 等操作</td>
                                </tr>
                                <tr>
                                    <td><strong>使用临时容器</strong></td>
                                    <td>通过 <code>docker run --rm</code> 启动，任务结束自动清理</td>
                                </tr>
                                <tr>
                                    <td><strong>限制宿主机访问</strong></td>
                                    <td>不挂载 <code>/etc</code>, <code>/root</code>, <code>/var/lib/docker</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h4>示例：临时调试容器启动脚本</h4>
                    <div class="config-block">
                        <pre><code>#!/bin/bash
# debug-kernel.sh

echo "Starting temporary kernel debugger..."
docker run --rm \
  --name kernel-debugger-temp \
  --network debug-isolated \
  --privileged \
  -v /lib/modules:/lib/modules:ro \
  -v /boot:/boot:ro \
  -v $(pwd)/debug:/debug \
  ubuntu:22.04 \
  sh -c "modprobe kgdboc kgdboc=ttyS0,115200 && echo g > /proc/sysrq-trigger && sleep 300"

echo "Container terminated. All resources cleaned up."</code></pre>
                    </div>

                    <h3>5. 合规性与审计追踪</h3>
                    <p>在金融、医疗、政府等受监管行业，<code>privileged: true</code> 的使用必须满足合规要求（如 ISO 27001、SOC 2、HIPAA）。</p>

                    <h4>审计追踪要求：</h4>
                    <ul class="list-disc pl-6 mb-4">
                        <li>所有 <code>privileged: true</code> 的使用必须记录在 <strong>变更管理日志</strong> 中；</li>
                        <li>每次启动必须记录：  
                            - 启动人  
                            - 启动时间  
                            - 目的  
                            - 审批人  
                            - 容器 ID  
                            - 结束时间</li>
                        <li>所有操作日志（<code>docker logs</code>, <code>auditd</code>）必须保留至少 180 天。</li>
                    </ul>

                    <h4>推荐工具：</h4>
                    <ul class="list-disc pl-6 mb-4">
                        <li><strong>ELK Stack</strong>（Elasticsearch, Logstash, Kibana）集中收集容器日志；</li>
                        <li><strong>Sysdig Secure</strong> 或 <strong>Falco</strong> 实时检测异常行为（如 <code>execve</code> 从 <code>/tmp</code> 启动）；</li>
                        <li><strong>HashiCorp Vault</strong> 管理临时凭证与访问权限。</li>
                    </ul>

                    <h3>6. 培训与意识提升</h3>
                    <p>安全不是工具的问题，而是人的意识问题。建议每季度开展一次《容器安全实践》培训，内容包括：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li><code>privileged: true</code> 的真实攻击案例（如 2021 年云服务商事件）；</li>
                        <li>如何使用 <code>cap_add</code> 实现相同功能；</li>
                        <li>演示“从特权容器逃逸到控制宿主机”的全过程；</li>
                        <li>模拟攻击演练（Red Team）。</li>
                    </ul>
                    <p><strong>培训效果评估</strong>：要求每位开发人员在通过考核后签署《容器安全承诺书》，方可提交涉及容器的代码。</p>

                    <h3>总结：构建“零信任”容器文化</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>原则</th>
                                    <th>实践</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>默认拒绝</strong></td>
                                    <td><code>privileged: true</code> 默认禁止，需主动申请</td>
                                </tr>
                                <tr>
                                    <td><strong>最小权限</strong></td>
                                    <td>仅授予必要能力，拒绝“全有或全无”</td>
                                </tr>
                                <tr>
                                    <td><strong>自动化强制</strong></td>
                                    <td>CI/CD 自动拦截违规配置</td>
                                </tr>
                                <tr>
                                    <td><strong>透明审计</strong></td>
                                    <td>所有操作可追溯、可审查</td>
                                </tr>
                                <tr>
                                    <td><strong>持续教育</strong></td>
                                    <td>安全是每个人的责任</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p><strong>最终结论</strong>：<code>privileged: true</code> 不应被视为“配置选项”，而应被视为“安全事件”。通过制度、工具、流程与文化的协同，团队可彻底消除其滥用风险，实现安全与效率的双赢。</p>
                </section>

                <section class="mb-12">
                    <h2>常见误区与用户高频问题解答</h2>
                    <p>在实际使用 <code>docker-compose.yml</code> 配置 <code>privileged: true</code> 或其替代方案时，用户常因对 Docker 安全模型理解不足而陷入误区。这些误区不仅导致配置无效，更可能引入安全隐患。本节将系统性梳理 12 个最常见误区，并提供清晰、准确、可操作的解答，帮助用户避免错误，提升配置质量。</p>

                    <h3>误区 1：挂载 /dev 就等于 privileged: true</h3>
                    <p><strong>错误认知</strong>：用户认为只要在 <code>volumes</code> 中挂载 <code>/dev:/dev</code>，容器就获得了与 <code>privileged: true</code> 相同的权限。</p>
                    <p><strong>事实澄清</strong>：  
                    挂载 <code>/dev</code> 仅使容器能访问设备文件，但<strong>不赋予执行特权操作的能力</strong>。例如：</p>
                    <div class="config-block">
                        <pre><code>volumes:
  - /dev:/dev</code></pre>
                    </div>
                    <p>容器内仍无法：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>加载内核模块（<code>modprobe</code> → <code>Operation not permitted</code>）；</li>
                        <li>挂载文件系统（<code>mount</code> → <code>Permission denied</code>）；</li>
                        <li>修改网络接口（<code>ip link set eth0 up</code> → <code>Operation not permitted</code>）。</li>
                    </ul>
                    <p><strong>正确做法</strong>：  
                    若需访问设备，使用 <code>devices</code> 指定具体设备；若需执行系统操作，使用 <code>cap_add</code>。</p>
                    <p><strong>✅ 正确</strong>：<code>devices: - /dev/ttyUSB0:/dev/ttyUSB0</code><br>
                    <strong>✅ 正确</strong>：<code>cap_add: - NET_ADMIN</code><br>
                    <strong>❌ 错误</strong>：仅挂载 <code>/dev</code> 就认为有特权</p>

                    <h3>误区 2：privileged: true 只在容器内有用，不影响宿主机</h3>
                    <p><strong>错误认知</strong>：用户认为容器是隔离的，即使启用特权，宿主机也不会受影响。</p>
                    <p><strong>事实澄清</strong>：  
                    <code>privileged: true</code> <strong>完全破坏了容器与宿主机的隔离边界</strong>。容器内的 root 用户与宿主机 root 用户是同一身份（UID=0）。攻击者可：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>读取 <code>/etc/shadow</code> 获取宿主机密码哈希；</li>
                        <li>修改 <code>/etc/ssh/sshd_config</code> 开启 root 登录；</li>
                        <li>挂载宿主机根文件系统并植入后门；</li>
                        <li>加载内核模块实现持久化驻留。</li>
                    </ul>
                    <p><strong>真实案例</strong>：2022 年，某公司因在 CI 环境中使用 <code>privileged: true</code> 运行构建脚本，攻击者通过恶意代码在容器内执行 <code>mount --bind / /mnt/host</code>，随后写入 <code>~/.ssh/authorized_keys</code>，成功入侵 47 台宿主机 <cite><a href="https://www.cisa.gov/news-events/alerts/2022/07/14/docker-privileged-containers-lead-to-host-compromise" target="_blank" rel="noopener noreferrer">[[3]]</a></cite>。</p>

                    <h3>误区 3：cap_add: ALL 和 privileged: true 是等价的</h3>
                    <p><strong>错误认知</strong>：用户认为 <code>cap_add: ALL</code> 是 <code>privileged: true</code> 的“安全替代”。</p>
                    <p><strong>事实澄清</strong>：  
                    在绝大多数情况下，<strong><code>cap_add: ALL</code> 等价于 <code>privileged: true</code></strong>。两者都会授予所有 38 种 Linux 能力，包括 <code>CAP_SYS_MODULE</code>、<code>CAP_SYS_RAWIO</code>、<code>CAP_SYS_BOOT</code> 等高危能力。</p>
                    <div class="config-block">
                        <pre><code>privileged: true
# 等价于
cap_add:
  - ALL
devices:
  - /dev:/dev</code></pre>
                    </div>
                    <p><strong>区别仅在于</strong>：  
                    - <code>privileged: true</code> 还会禁用 seccomp、AppArmor、user namespace；  
                    - <code>cap_add: ALL</code> 仍保留这些安全机制（除非手动禁用）。</p>
                    <p><strong>⚠️ 结论</strong>：<code>cap_add: ALL</code> 与 <code>privileged: true</code> 在安全风险上<strong>无本质区别</strong>，均应避免使用。</p>

                    <h3>误区 4：我只在开发环境用 privileged: true，没关系</h3>
                    <p><strong>错误认知</strong>：用户认为开发环境不对外暴露，风险可控。</p>
                    <p><strong>事实澄清</strong>：  
                    开发环境往往是攻击者的首选目标，原因包括：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>安全措施薄弱（无审计、无扫描）；</li>
                        <li>开发者常使用高权限账户；</li>
                        <li>代码与配置未经审查；</li>
                        <li>容器常挂载本地代码目录（<code>./src:/app</code>），攻击者可注入恶意代码。</li>
                    </ul>
                    <p><strong>案例</strong>：2023 年，某开源项目因开发者在本地 <code>docker-compose.yml</code> 中使用 <code>privileged: true</code>，攻击者通过 GitHub Actions 恶意 PR 注入脚本，在构建时窃取了开发者的 SSH 密钥，进而入侵了生产环境 <cite><a href="https://security.googleblog.com/2023/03/attackers-compromise-open-source.html" target="_blank" rel="noopener noreferrer">[[4]]</a></cite>。</p>
                    <p><strong>正确做法</strong>：  
                    开发环境应与生产环境使用<strong>相同的最小权限配置</strong>。若需调试，使用 <code>cap_add</code> + <code>SYS_PTRACE</code>，而非 <code>privileged</code>。</p>

                    <h3>误区 5：我用 --user root 就能解决权限问题，不需要特权</h3>
                    <p><strong>错误认知</strong>：用户认为只要指定 <code>user: root</code>，就能像宿主机 root 一样操作。</p>
                    <p><strong>事实澄清</strong>：  
                    即使容器内用户是 root，<strong>仍受 Linux 能力限制</strong>。例如：</p>
                    <div class="config-block">
                        <pre><code>user: root</code></pre>
                    </div>
                    <p>容器内仍无法：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li><code>mount /dev/sda1 /mnt</code> → <code>Operation not permitted</code></li>
                        <li><code>ip addr add 192.168.1.100/24 dev eth0</code> → <code>Operation not permitted</code></li>
                    </ul>
                    <p><strong>正确做法</strong>：  
                    若需执行系统操作，必须使用 <code>cap_add</code> 添加对应能力，而非仅依赖 <code>user: root</code>。</p>

                    <h3>误区 6：read_only: true 会阻止 privileged: true 的危害</h3>
                    <p><strong>错误认知</strong>：用户认为只读根文件系统能防止攻击者写入恶意文件。</p>
                    <p><strong>事实澄清</strong>：  
                    <code>read_only: true</code> 仅限制容器根文件系统，但：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>容器仍可挂载宿主机的可写目录（如 <code>/tmp</code>, <code>/var/tmp</code>）；</li>
                        <li>可通过 <code>mount --bind</code> 将宿主机 <code>/etc</code> 挂载到容器内并修改；</li>
                        <li>可通过 <code>modprobe</code> 加载内核模块，实现持久化后门（不依赖文件系统）。</li>
                    </ul>
                    <p><strong>结论</strong>：<code>read_only</code> 是良好实践，但<strong>不能防御特权容器的系统级攻击</strong>。</p>

                    <h3>误区 7：我用 network_mode: host 就不需要 privileged: true</h3>
                    <p><strong>错误认知</strong>：用户认为使用 <code>host</code> 网络模式就等于获得了网络特权。</p>
                    <p><strong>事实澄清</strong>：  
                    <code>network_mode: host</code> 仅使容器共享宿主机的网络命名空间，<strong>不赋予网络管理能力</strong>。例如：</p>
                    <div class="config-block">
                        <pre><code>network_mode: host</code></pre>
                    </div>
                    <p>容器仍无法：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>创建新网络接口（<code>ip link add</code>）；</li>
                        <li>修改路由表（<code>ip route add</code>）；</li>
                        <li>配置 iptables 规则（<code>iptables -A INPUT -j DROP</code>）。</li>
                    </ul>
                    <p><strong>正确做法</strong>：  
                    若需网络管理，使用 <code>cap_add: NET_ADMIN</code>，而非依赖 <code>host</code> 网络。</p>

                    <h3>误区 8：cap_add: SYS_ADMIN 是安全的，可以随意使用</h3>
                    <p><strong>错误认知</strong>：用户认为 <code>SYS_ADMIN</code> 是“普通管理员能力”，风险较低。</p>
                    <p><strong>事实澄清</strong>：  
                    <code>CAP_SYS_ADMIN</code> 是<strong>最危险的 Linux 能力之一</strong>，允许：</p>
                    <ul class="list-disc pl-6 mb-4">
                        <li>挂载/卸载任意文件系统（包括 <code>/proc</code>, <code>/sys</code>, <code>/dev</code>）；</li>
                        <li>使用 <code>chroot</code> 逃逸；</li>
                        <li>修改主机名、时区、内核参数；</li>
                        <li>操作 cgroups、namespaces。</li>
                    </ul>
                    <p><strong>攻击链示例</strong>：  
                    <code>mount --bind / /mnt/host</code> → <code>chroot /mnt/host</code> → <code>cat /etc/shadow</code> → <strong>完全控制宿主机</strong></p>
                    <p><strong>正确做法</strong>：  
                    除非绝对必要（如运行 <code>mount</code> 命令），否则<strong>禁止使用 <code>CAP_SYS_ADMIN</code></strong>。优先使用 <code>devices</code> 挂载特定设备。</p>

                    <h3>误区 9：我用 --rm 就安全了，容器删除后不留痕迹</h3>
                    <p><strong>错误认知</strong>：用户认为容器销毁后，攻击痕迹也随之消失。</p>
                    <p><strong>事实澄清</strong>：  
                    若容器曾使用 <code>privileged: true</code> 并加载了内核模块，<strong>模块可能仍驻留在宿主机内核中</strong>，即使容器被删除，后门依然存在。</p>
                    <p><strong>检测方法</strong>：  
                    在宿主机执行 <code>lsmod | grep malicious_module</code>，若发现未知模块，说明已被植入。</p>
                    <p><strong>正确做法</strong>：  
                    - 使用 <code>auditd</code> 监控 <code>modprobe</code>；  
                    - 定期重启宿主机以清除内核模块；  
                    - 避免在长期运行的宿主机上使用 <code>privileged</code>。</p>

                    <h3>误区 10：我只在本地 Docker Desktop 上用，不会出事</h3>
                    <p><strong>错误认知</strong>：用户认为 Docker Desktop 是“个人工具”，无安全风险。</p>
                    <p><strong>事实澄清</strong>：  
                    Docker Desktop 在 macOS/Windows 上运行在 Linux 虚拟机中，<code>privileged: true</code> 会<strong>直接威胁整个虚拟机</strong>，进而影响宿主机系统。</p>
                    <p><strong>案例</strong>：攻击者通过恶意镜像在 Docker Desktop 容器中执行 <code>mount --bind /host_mnt /mnt</code>，访问 macOS 的 <code>/Users</code> 目录，窃取所有本地文件。</p>

                    <h3>误区 11：我用 --privileged 是因为 docker-compose 不支持 cap_add</h3>
                    <p><strong>错误认知</strong>：用户误以为 <code>cap_add</code> 是 Docker Engine 的功能，Docker Compose 不支持。</p>
                    <p><strong>事实澄清</strong>：  
                    <code>cap_add</code> 是 Docker Compose <strong>从 version 2.0 起就完全支持的标准配置项</strong>。</p>
                    <div class="config-block">
                        <pre><code>version: '3.8'
services:
  myservice:
    image: ubuntu
    cap_add:
      - NET_ADMIN</code></pre>
                    </div>
                    <p><strong>正确做法</strong>：  
                    使用 <code>cap_add</code> 替代 <code>privileged</code>，无需任何妥协。</p>

                    <h3>误区 12：我找不到替代方案，只能用 privileged: true</h3>
                    <p><strong>错误认知</strong>：用户认为某些功能（如运行 <code>systemd</code>、<code>udev</code>）必须依赖特权。</p>
                    <p><strong>事实澄清</strong>：  
                    几乎所有“必须特权”的场景都有替代方案：</p>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>需求</th>
                                    <th>替代方案</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>运行 systemd</td>
                                    <td>使用 <code>--tmpfs /run --tmpfs /tmp</code> + <code>--cap-add=SYS_ADMIN</code></td>
                                </tr>
                                <tr>
                                    <td>访问 udev 设备</td>
                                    <td>使用 <code>devices: - /dev:/dev</code> + <code>cap_add: SYS_ADMIN</code></td>
                                </tr>
                                <tr>
                                    <td>挂载 CIFS/NFS</td>
                                    <td>使用 <code>cap_add: SYS_ADMIN</code> + <code>mount</code> 命令</td>
                                </tr>
                                <tr>
                                    <td>运行 iptables</td>
                                    <td>使用 <code>cap_add: NET_ADMIN</code></td>
                                </tr>
                                <tr>
                                    <td>调试进程</td>
                                    <td>使用 <code>cap_add: SYS_PTRACE</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p><strong>结论</strong>：<strong>不存在“必须使用 privileged: true”的合法场景</strong>，只有“尚未找到替代方案”的技术惰性。</p>

                    <h3>总结：安全配置 Checklist</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>检查项</th>
                                    <th>是否满足</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>是否使用 <code>privileged: true</code>？</td>
                                    <td>❌ 应为“否”</td>
                                </tr>
                                <tr>
                                    <td>是否使用 <code>cap_add: ALL</code>？</td>
                                    <td>❌ 应为“否”</td>
                                </tr>
                                <tr>
                                    <td>是否挂载 <code>/dev</code>？</td>
                                    <td>❌ 应仅挂载特定设备（<code>devices</code>）</td>
                                </tr>
                                <tr>
                                    <td>是否使用 <code>network_mode: host</code>？</td>
                                    <td>⚠️ 仅在必要时使用，配合 <code>cap_add</code></td>
                                </tr>
                                <tr>
                                    <td>是否使用 <code>user: root</code>？</td>
                                    <td>⚠️ 应使用非 root 用户</td>
                                </tr>
                                <tr>
                                    <td>是否启用 <code>read_only: true</code>？</td>
                                    <td>✅ 推荐</td>
                                </tr>
                                <tr>
                                    <td>是否启用 <code>security_opt: seccomp</code>？</td>
                                    <td>✅ 推荐</td>
                                </tr>
                                <tr>
                                    <td>是否在 CI/CD 中扫描 <code>privileged</code>？</td>
                                    <td>✅ 必须</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p><strong>最终建议</strong>：<strong>永远不要使用 privileged: true</strong>。若你认为你“必须”使用它，请重新审视你的架构设计。真正的专业开发者，从不依赖特权，而是通过精确的权限控制实现功能。</p>
                </section>
            </div>

            <div class="section-nav">
                <h3 class="text-sm font-semibold mb-3">目录</h3>
                <ul>
                    <li><a href="#overview">概述</a></li>
                    <li><a href="#correct-position">正确层级位置</a></li>
                    <li><a href="#security-warning">安全警告</a></li>
                    <li><a href="#alternatives">替代方案</a></li>
                    <li><a href="#examples">完整配置示例</a></li>
                    <li><a href="#best-practices">安全审计与最佳实践</a></li>
                    <li><a href="#common-mistakes">常见误区</a></li>
                </ul>
            </div>
        </div>
    </div>

    <footer class="bg-white border-t border-gray-200 mt-16 py-8">
        <p class="text-center text-gray-600">
            Created by Autobots<br>
            页面内容均由 AI 生成，仅供参考
        </p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const sectionLinks = document.querySelectorAll('.section-nav a');
            const sections = document.querySelectorAll('section');
            
            function updateActiveLink() {
                let currentSection = '';
                const scrollPosition = window.scrollY + 100;
                
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    const sectionHeight = section.clientHeight;
                    
                    if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                        currentSection = section.id;
                    }
                });
                
                sectionLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + currentSection) {
                        link.classList.add('active');
                    }
                });
            }
            
            window.addEventListener('scroll', updateActiveLink);
            updateActiveLink();
        });
    </script>
</body>
</html>
